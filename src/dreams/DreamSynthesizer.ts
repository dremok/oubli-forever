/**
 * DREAM SYNTHESIZER — the system dreams of your memories
 *
 * Every 2-4 minutes, Oubli "dreams." It takes fragments from:
 * - User memories (from the journal)
 * - Whisper fragments (philosophy, neuroscience)
 * - Extinction words
 * - Digital decay epitaphs
 *
 * ...and recombines them into surreal new sentences. These dreams
 * appear as large, slowly pulsing text in the center of the screen,
 * rendered in a dreamy, blurred style. They last 8-12 seconds
 * before dissolving.
 *
 * The dreams are generated by a simple Markov-like process:
 * split sources into word chunks, randomly interleave them,
 * apply grammatical smoothing. The result is poetic nonsense
 * that sometimes, accidentally, means something.
 *
 * This is the system's subconscious. It processes what you give it
 * and returns something transformed — like how real dreams remix
 * the day's experiences into surreal narratives.
 *
 * Inspired by: William Burroughs's cut-up technique, Brion Gysin,
 * the hypnagogic state, dream journals, sleep talking
 */

// Built-in dream fragments for when there are no user memories
const DREAM_SEEDS = [
  'the light remembers what the dark forgot',
  'every name dissolves into the same silence',
  'we are the amnesia between two thoughts',
  'the cursor blinks where you used to be',
  'time pools in the spaces between letters',
  'your voice left an outline in the static',
  'the pixels reorganize themselves around absence',
  'somewhere a server still holds your first search',
  'the void hums in frequencies you once knew',
  'all passwords eventually become prayers',
  'memory is the wound that heals into a scar of light',
  'the archive dreams of pages it never saved',
  'each refresh is a small death and resurrection',
  'your bookmarks are a map of who you were',
  'the last word you typed is still falling',
  'forgetting is the brain writing over itself in invisible ink',
  'the sound of one neuron firing is the same as silence',
  'data centers dream in the language of heat',
  'every photograph steals a moment from entropy',
  'the cloud is just rain that hasnt fallen yet',
]

// Sentence templates for dream generation
const TEMPLATES = [
  '{a} becomes {b}',
  'in the place where {a}, {b} waits',
  '{a} and {b} share the same dream',
  'the memory of {a} dissolves into {b}',
  'between {a} and {b}, silence grows',
  '{a} — but {b}',
  'what if {a} is just {b} in disguise',
  'they found {a} where {b} used to sleep',
  '{a} whispers to {b} across the void',
  'the ghost of {a} haunts {b}',
  'first {a}, then nothing, then {b}',
  '{a} forgotten, {b} remembered, both dissolving',
]

interface DreamDisplay {
  text: string
  alpha: number
  phase: 'fadein' | 'visible' | 'fadeout' | 'gone'
  timer: number
  y: number
  blur: number
}

export class DreamSynthesizer {
  private canvas: HTMLCanvasElement
  private ctx: CanvasRenderingContext2D
  private currentDream: DreamDisplay | null = null
  private userMemories: string[] = []
  private frameId = 0
  private animating = false
  private width = 0
  private height = 0
  private dpr = 1
  private frame = 0
  private nextDreamFrame = 0
  private hidden = false
  private dreamCallback: ((text: string) => void) | null = null

  // Model collapse tracking
  private generatedDreams: string[] = [] // dreams feed back as source material
  private generation = 0 // how many dreams have been generated this session
  private wordFrequency = new Map<string, number>() // tracks word usage

  constructor() {
    this.canvas = document.createElement('canvas')
    this.canvas.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      z-index: 180; pointer-events: none;
    `
    document.body.appendChild(this.canvas)
    this.ctx = this.canvas.getContext('2d')!
    this.resize()
    window.addEventListener('resize', () => this.resize())
  }

  private resize() {
    this.dpr = Math.min(window.devicePixelRatio, 2)
    this.width = window.innerWidth
    this.height = window.innerHeight
    this.canvas.width = this.width * this.dpr
    this.canvas.height = this.height * this.dpr
    this.canvas.style.width = this.width + 'px'
    this.canvas.style.height = this.height + 'px'
    this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0)
  }

  /** Feed user memories for dream material */
  addMemory(text: string) {
    this.userMemories.push(text)
  }

  /** Load existing memories */
  loadMemories(texts: string[]) {
    this.userMemories = texts
  }

  start() {
    // First dream after 2 minutes
    this.nextDreamFrame = 120 * 60
    this.startAnimation()
  }

  private startAnimation() {
    if (this.animating) return
    this.animating = true

    const animate = () => {
      this.frameId = requestAnimationFrame(animate)
      this.frame++
      this.update()
      this.render()
    }
    animate()
  }

  private update() {
    // Spawn new dream
    if (this.frame >= this.nextDreamFrame && !this.currentDream) {
      this.spawnDream()
      // Next dream in 2-4 minutes
      this.nextDreamFrame = this.frame + (120 + Math.random() * 120) * 60
    }

    // Update current dream
    if (this.currentDream) {
      const d = this.currentDream
      d.timer++

      switch (d.phase) {
        case 'fadein':
          d.alpha += 0.008
          d.blur = Math.max(0, d.blur - 0.1)
          if (d.alpha >= 0.6) {
            d.alpha = 0.6
            d.phase = 'visible'
            d.timer = 0
          }
          break

        case 'visible':
          // Gentle floating
          d.y += Math.sin(d.timer * 0.01) * 0.05
          // Linger for 8-12 seconds
          if (d.timer > (8 + Math.random() * 4) * 60) {
            d.phase = 'fadeout'
          }
          break

        case 'fadeout':
          d.alpha -= 0.005
          d.blur += 0.08
          d.y -= 0.15 // drift upward as it dissolves
          if (d.alpha <= 0) {
            d.phase = 'gone'
            this.currentDream = null
          }
          break
      }
    }
  }

  private spawnDream() {
    const dreamText = this.generateDream()

    this.currentDream = {
      text: dreamText,
      alpha: 0,
      phase: 'fadein',
      timer: 0,
      y: this.height * 0.45,
      blur: 8,
    }

    // Notify listeners (e.g., DreamVisions for image generation)
    this.dreamCallback?.(dreamText)
  }

  private generateDream(): string {
    this.generation++

    // MODEL COLLAPSE: as generations increase, previous dreams increasingly
    // replace original sources. The system feeds on its own output.
    const collapseRatio = Math.min(this.generation / 20, 0.8) // max 80% self-referential

    // Build source pool with collapse weighting
    const sources: string[] = []

    // Original material (decreases with collapse)
    const origCount = Math.max(2, Math.round((1 - collapseRatio) * 10))
    for (let i = 0; i < origCount; i++) {
      sources.push(DREAM_SEEDS[Math.floor(Math.random() * DREAM_SEEDS.length)])
    }
    if (this.userMemories.length > 0) {
      for (let i = 0; i < origCount; i++) {
        sources.push(this.userMemories[Math.floor(Math.random() * this.userMemories.length)])
      }
    }

    // Generated dreams feed back (increases with collapse)
    if (this.generatedDreams.length > 0) {
      const genCount = Math.round(collapseRatio * 12)
      for (let i = 0; i < genCount; i++) {
        sources.push(this.generatedDreams[Math.floor(Math.random() * this.generatedDreams.length)])
      }
    }

    let dream: string

    // Method 1: Template-based combination (60% chance)
    if (Math.random() < 0.6) {
      const template = TEMPLATES[Math.floor(Math.random() * TEMPLATES.length)]
      const a = this.extractFragment(sources)
      const b = this.extractFragment(sources)
      dream = template.replace('{a}', a).replace('{b}', b)
    } else {
      // Method 2: Word-level recombination
      const src1 = sources[Math.floor(Math.random() * sources.length)]
      const src2 = sources[Math.floor(Math.random() * sources.length)]

      const words1 = src1.toLowerCase().split(/\s+/)
      const words2 = src2.toLowerCase().split(/\s+/)

      const result: string[] = []
      const maxLen = Math.max(words1.length, words2.length)

      for (let i = 0; i < maxLen; i++) {
        if (Math.random() < 0.5 && i < words1.length) {
          result.push(words1[i])
        } else if (i < words2.length) {
          result.push(words2[i])
        }
      }

      dream = result.slice(0, 8 + Math.floor(Math.random() * 6)).join(' ')
    }

    // MODEL COLLAPSE: bias toward already-frequent words
    if (collapseRatio > 0.3) {
      dream = this.applyFrequencyBias(dream, collapseRatio)
    }

    // Track this dream for future collapse
    this.generatedDreams.push(dream)
    // Keep only last 30 generated dreams
    if (this.generatedDreams.length > 30) {
      this.generatedDreams.shift()
    }

    // Update word frequency
    for (const word of dream.toLowerCase().split(/\s+/)) {
      this.wordFrequency.set(word, (this.wordFrequency.get(word) || 0) + 1)
    }

    return dream
  }

  /** Bias toward frequently-used words — vocabulary narrows over generations */
  private applyFrequencyBias(text: string, collapse: number): string {
    if (this.wordFrequency.size === 0) return text

    const words = text.split(/\s+/)
    const result: string[] = []

    // Get most frequent words
    const sorted = [...this.wordFrequency.entries()]
      .sort((a, b) => b[1] - a[1])
      .slice(0, 20)
      .map(([w]) => w)

    for (const word of words) {
      // Chance to replace with a more "collapsed" (frequent) word
      if (Math.random() < collapse * 0.25 && sorted.length > 0) {
        result.push(sorted[Math.floor(Math.random() * Math.min(sorted.length, 5))])
      } else {
        result.push(word)
      }
    }

    return result.join(' ')
  }

  private extractFragment(sources: string[]): string {
    const source = sources[Math.floor(Math.random() * sources.length)]
    const words = source.toLowerCase().split(/\s+/)

    // Extract 2-5 consecutive words
    const start = Math.floor(Math.random() * Math.max(1, words.length - 3))
    const len = 2 + Math.floor(Math.random() * 3)
    return words.slice(start, start + len).join(' ')
  }

  /** Get current collapse generation count */
  getGeneration(): number {
    return this.generation
  }

  /** Register callback for when a new dream is synthesized */
  onDream(fn: (text: string) => void) {
    this.dreamCallback = fn
  }

  setVisible(v: boolean) {
    this.hidden = !v
    if (this.hidden) {
      this.ctx.clearRect(0, 0, this.width, this.height)
    }
  }

  private render() {
    const ctx = this.ctx
    ctx.clearRect(0, 0, this.width, this.height)

    if (this.hidden) return
    if (!this.currentDream || this.currentDream.phase === 'gone') return

    const d = this.currentDream
    const centerX = this.width / 2

    // Apply blur via shadow trick
    ctx.save()

    const fontSize = Math.min(this.width * 0.035, 30)
    ctx.font = `300 italic ${fontSize}px 'Cormorant Garamond', serif`
    ctx.textAlign = 'center'
    ctx.textBaseline = 'middle'

    // Word wrap
    const maxWidth = this.width * 0.55
    const words = d.text.split(' ')
    const lines: string[] = []
    let currentLine = ''

    for (const word of words) {
      const testLine = currentLine + (currentLine ? ' ' : '') + word
      if (ctx.measureText(testLine).width > maxWidth && currentLine) {
        lines.push(currentLine)
        currentLine = word
      } else {
        currentLine = testLine
      }
    }
    if (currentLine) lines.push(currentLine)

    const lineHeight = fontSize * 1.5
    const totalHeight = lines.length * lineHeight

    // Dream glow
    ctx.shadowColor = `rgba(147, 112, 219, ${d.alpha * 0.6})`
    ctx.shadowBlur = 15 + d.blur

    // Render each line
    for (let i = 0; i < lines.length; i++) {
      const lineY = d.y - totalHeight / 2 + i * lineHeight

      // Color: dreamy lavender/violet
      ctx.fillStyle = `rgba(180, 160, 220, ${d.alpha})`
      ctx.fillText(lines[i], centerX, lineY)
    }

    // Second pass without blur for crispness
    ctx.shadowBlur = 0
    ctx.shadowColor = 'transparent'

    for (let i = 0; i < lines.length; i++) {
      const lineY = d.y - totalHeight / 2 + i * lineHeight
      ctx.fillStyle = `rgba(200, 185, 235, ${d.alpha * 0.4})`
      ctx.fillText(lines[i], centerX, lineY)
    }

    ctx.restore()
  }

  destroy() {
    cancelAnimationFrame(this.frameId)
    this.canvas.remove()
  }
}
