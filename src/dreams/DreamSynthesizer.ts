/**
 * DREAM SYNTHESIZER — the system dreams of your memories
 *
 * Every 2-4 minutes, Oubli "dreams." It takes fragments from:
 * - User memories (from the journal)
 * - Whisper fragments (philosophy, neuroscience)
 * - Extinction words
 * - Digital decay epitaphs
 *
 * ...and recombines them into surreal new sentences. These dreams
 * appear as large, slowly pulsing text in the center of the screen,
 * rendered in a dreamy, blurred style. They last 8-12 seconds
 * before dissolving.
 *
 * The dreams are generated by a simple Markov-like process:
 * split sources into word chunks, randomly interleave them,
 * apply grammatical smoothing. The result is poetic nonsense
 * that sometimes, accidentally, means something.
 *
 * This is the system's subconscious. It processes what you give it
 * and returns something transformed — like how real dreams remix
 * the day's experiences into surreal narratives.
 *
 * Inspired by: William Burroughs's cut-up technique, Brion Gysin,
 * the hypnagogic state, dream journals, sleep talking
 */

// Built-in dream fragments for when there are no user memories
const DREAM_SEEDS = [
  'the light remembers what the dark forgot',
  'every name dissolves into the same silence',
  'we are the amnesia between two thoughts',
  'the cursor blinks where you used to be',
  'time pools in the spaces between letters',
  'your voice left an outline in the static',
  'the pixels reorganize themselves around absence',
  'somewhere a server still holds your first search',
  'the void hums in frequencies you once knew',
  'all passwords eventually become prayers',
  'memory is the wound that heals into a scar of light',
  'the archive dreams of pages it never saved',
  'each refresh is a small death and resurrection',
  'your bookmarks are a map of who you were',
  'the last word you typed is still falling',
  'forgetting is the brain writing over itself in invisible ink',
  'the sound of one neuron firing is the same as silence',
  'data centers dream in the language of heat',
  'every photograph steals a moment from entropy',
  'the cloud is just rain that hasnt fallen yet',
]

// Sentence templates for dream generation
const TEMPLATES = [
  '{a} becomes {b}',
  'in the place where {a}, {b} waits',
  '{a} and {b} share the same dream',
  'the memory of {a} dissolves into {b}',
  'between {a} and {b}, silence grows',
  '{a} — but {b}',
  'what if {a} is just {b} in disguise',
  'they found {a} where {b} used to sleep',
  '{a} whispers to {b} across the void',
  'the ghost of {a} haunts {b}',
  'first {a}, then nothing, then {b}',
  '{a} forgotten, {b} remembered, both dissolving',
]

interface DreamDisplay {
  text: string
  alpha: number
  phase: 'fadein' | 'visible' | 'fadeout' | 'gone'
  timer: number
  y: number
  blur: number
}

export class DreamSynthesizer {
  private canvas: HTMLCanvasElement
  private ctx: CanvasRenderingContext2D
  private currentDream: DreamDisplay | null = null
  private userMemories: string[] = []
  private frameId = 0
  private animating = false
  private width = 0
  private height = 0
  private dpr = 1
  private frame = 0
  private nextDreamFrame = 0

  constructor() {
    this.canvas = document.createElement('canvas')
    this.canvas.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      z-index: 180; pointer-events: none;
    `
    document.body.appendChild(this.canvas)
    this.ctx = this.canvas.getContext('2d')!
    this.resize()
    window.addEventListener('resize', () => this.resize())
  }

  private resize() {
    this.dpr = Math.min(window.devicePixelRatio, 2)
    this.width = window.innerWidth
    this.height = window.innerHeight
    this.canvas.width = this.width * this.dpr
    this.canvas.height = this.height * this.dpr
    this.canvas.style.width = this.width + 'px'
    this.canvas.style.height = this.height + 'px'
    this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0)
  }

  /** Feed user memories for dream material */
  addMemory(text: string) {
    this.userMemories.push(text)
  }

  /** Load existing memories */
  loadMemories(texts: string[]) {
    this.userMemories = texts
  }

  start() {
    // First dream after 2 minutes
    this.nextDreamFrame = 120 * 60
    this.startAnimation()
  }

  private startAnimation() {
    if (this.animating) return
    this.animating = true

    const animate = () => {
      this.frameId = requestAnimationFrame(animate)
      this.frame++
      this.update()
      this.render()
    }
    animate()
  }

  private update() {
    // Spawn new dream
    if (this.frame >= this.nextDreamFrame && !this.currentDream) {
      this.spawnDream()
      // Next dream in 2-4 minutes
      this.nextDreamFrame = this.frame + (120 + Math.random() * 120) * 60
    }

    // Update current dream
    if (this.currentDream) {
      const d = this.currentDream
      d.timer++

      switch (d.phase) {
        case 'fadein':
          d.alpha += 0.008
          d.blur = Math.max(0, d.blur - 0.1)
          if (d.alpha >= 0.6) {
            d.alpha = 0.6
            d.phase = 'visible'
            d.timer = 0
          }
          break

        case 'visible':
          // Gentle floating
          d.y += Math.sin(d.timer * 0.01) * 0.05
          // Linger for 8-12 seconds
          if (d.timer > (8 + Math.random() * 4) * 60) {
            d.phase = 'fadeout'
          }
          break

        case 'fadeout':
          d.alpha -= 0.005
          d.blur += 0.08
          d.y -= 0.15 // drift upward as it dissolves
          if (d.alpha <= 0) {
            d.phase = 'gone'
            this.currentDream = null
          }
          break
      }
    }
  }

  private spawnDream() {
    const dreamText = this.generateDream()

    this.currentDream = {
      text: dreamText,
      alpha: 0,
      phase: 'fadein',
      timer: 0,
      y: this.height * 0.45,
      blur: 8,
    }
  }

  private generateDream(): string {
    // Combine user memories with built-in seeds
    const sources = [...DREAM_SEEDS]
    if (this.userMemories.length > 0) {
      sources.push(...this.userMemories)
    }

    // Method 1: Template-based combination (60% chance)
    if (Math.random() < 0.6) {
      const template = TEMPLATES[Math.floor(Math.random() * TEMPLATES.length)]
      const a = this.extractFragment(sources)
      const b = this.extractFragment(sources)
      return template.replace('{a}', a).replace('{b}', b)
    }

    // Method 2: Word-level recombination (40% chance)
    const src1 = sources[Math.floor(Math.random() * sources.length)]
    const src2 = sources[Math.floor(Math.random() * sources.length)]

    const words1 = src1.toLowerCase().split(/\s+/)
    const words2 = src2.toLowerCase().split(/\s+/)

    // Interleave words from both sources
    const result: string[] = []
    const maxLen = Math.max(words1.length, words2.length)

    for (let i = 0; i < maxLen; i++) {
      if (Math.random() < 0.5 && i < words1.length) {
        result.push(words1[i])
      } else if (i < words2.length) {
        result.push(words2[i])
      }
    }

    // Trim to reasonable length
    return result.slice(0, 8 + Math.floor(Math.random() * 6)).join(' ')
  }

  private extractFragment(sources: string[]): string {
    const source = sources[Math.floor(Math.random() * sources.length)]
    const words = source.toLowerCase().split(/\s+/)

    // Extract 2-5 consecutive words
    const start = Math.floor(Math.random() * Math.max(1, words.length - 3))
    const len = 2 + Math.floor(Math.random() * 3)
    return words.slice(start, start + len).join(' ')
  }

  private render() {
    const ctx = this.ctx
    ctx.clearRect(0, 0, this.width, this.height)

    if (!this.currentDream || this.currentDream.phase === 'gone') return

    const d = this.currentDream
    const centerX = this.width / 2

    // Apply blur via shadow trick
    ctx.save()

    const fontSize = Math.min(this.width * 0.035, 30)
    ctx.font = `300 italic ${fontSize}px 'Cormorant Garamond', serif`
    ctx.textAlign = 'center'
    ctx.textBaseline = 'middle'

    // Word wrap
    const maxWidth = this.width * 0.55
    const words = d.text.split(' ')
    const lines: string[] = []
    let currentLine = ''

    for (const word of words) {
      const testLine = currentLine + (currentLine ? ' ' : '') + word
      if (ctx.measureText(testLine).width > maxWidth && currentLine) {
        lines.push(currentLine)
        currentLine = word
      } else {
        currentLine = testLine
      }
    }
    if (currentLine) lines.push(currentLine)

    const lineHeight = fontSize * 1.5
    const totalHeight = lines.length * lineHeight

    // Dream glow
    ctx.shadowColor = `rgba(147, 112, 219, ${d.alpha * 0.6})`
    ctx.shadowBlur = 15 + d.blur

    // Render each line
    for (let i = 0; i < lines.length; i++) {
      const lineY = d.y - totalHeight / 2 + i * lineHeight

      // Color: dreamy lavender/violet
      ctx.fillStyle = `rgba(180, 160, 220, ${d.alpha})`
      ctx.fillText(lines[i], centerX, lineY)
    }

    // Second pass without blur for crispness
    ctx.shadowBlur = 0
    ctx.shadowColor = 'transparent'

    for (let i = 0; i < lines.length; i++) {
      const lineY = d.y - totalHeight / 2 + i * lineHeight
      ctx.fillStyle = `rgba(200, 185, 235, ${d.alpha * 0.4})`
      ctx.fillText(lines[i], centerX, lineY)
    }

    ctx.restore()
  }

  destroy() {
    cancelAnimationFrame(this.frameId)
    this.canvas.remove()
  }
}
